!function(e){const t=new Map;e.Liferay=e.Liferay||{},e.Liferay.FnKit=e.Liferay.FnKit||{},e.Liferay.FnKit.createBatchedFetcher=function(e,{debounceTime:r=100,cacheTTL:a=0,retries:n=2,retryDelay:o=200,idToKey:c=(e=>e.toString()),logger:s=(()=>{}),batchable:i=!0}={}){const u=e.toString()+r+a+n+o+i;if(t.has(u))return t.get(u);const f=new Map,l=new Map;let y=null;const h=function(e){const t=c(e);if(a>0&&l.has(t)){const{value:e,expiresAt:r}=l.get(t);if(Date.now()<r)return s("info","cache.hit",{key:t,value:e}),Promise.resolve(e);l.delete(t),s("debug","cache.expired",{key:t})}return new Promise(((e,a)=>{f.has(t)||f.set(t,[]),f.get(t).push({resolve:e,reject:a}),s("debug","queue.added",{key:t}),y&&clearTimeout(y),y=setTimeout(w,r)}))};async function w(){const t=Array.from(f.keys()),r=new Map(f);f.clear(),s("info","batch.start",{keys:t});try{const u=i?e:(c=e,async function(e){const t=await Promise.all(e.map((async e=>{const t=await c(e);return[e.toString(),t]})));return Object.fromEntries(t)}),f=await async function(e,t,r){for(let a=0;a<=t;a++)try{return await e()}catch(e){if(a===t)throw e;const n=r*Math.pow(2,a);s("warn","retry.attempt",{attempt:a+1,delay:n}),await new Promise((e=>setTimeout(e,n)))}}((()=>u(t.map(m))),n,o);s("debug","batch.success",{results:f});for(const[e,t]of r)if(f&&Object.prototype.hasOwnProperty.call(f,e))a>0&&(l.set(e,{value:f[e],expiresAt:Date.now()+a}),s("debug","cache.set",{key:e,value:f[e]})),t.forEach((({resolve:t})=>t(f[e])));else{const r=new Error(`No result for ID: ${e}`);s("warn","batch.missing",{key:e}),t.forEach((({reject:e})=>e(r)))}}catch(e){s("error","batch.error",{error:e});for(const t of r.values())t.forEach((({reject:t})=>t(e)))}var c}function m(e){return/^\d+$/.test(e)?Number(e):e}return t.set(u,h),h}}(window);